Thimbles:
- Initial thought: The problem requires determining the position of the ball after a series of swaps between thimbles. My initial thought is to initialize the ball's position as 1 (as stated as the problem's rule) and iterate through the swap operations. For each swap, I convert the number string to integer and check if the ball is under one of the swapped thimbles and, if so, update its position accordingly. The approach is straightforward, and I will use a simple loop to process the swaps.
- Reflections: The code worked as expected, and the ball's final position was correctly determined in all test cases. The logic is simple, and by iterating through each swap, I ensured that the solution efficiently handles the problem. Overall, I'm happy with the readability and performance of my solution.

MatchNumbersEasy
- Initial thought: I got a bit confused when I first read the rules of the problem. But I eventually figured it out after a while of reading. The problem requires constructing the largest possible number using a given number of matches, with each digit consuming a different number of matches. For a suitable way of implementing the rules, it was really tricky for me at first. My first thought is to use dynamic programming (DP) to compute the largest number that can be formed for each possible number of matches from 0 to n. The idea is to build the result iteratively, considering each digit and how many matches it consumes, ensuring that we maximize the result at each step by comparing potential numbers.
- Reflections: I got a bit irritated when it comes to some cases when the program just wanna use all the matches and doesn't address to largest possible digit, leading to returning only zeroes results. I fixed the case eventually. Anyway, the DP approach worked as expected, and the solution was able to construct the correct largest number in all test cases. I'm not really sure about the readability of the codes as it may varies among readers, but for now, I'm good with the current layout of the codes.

NumberSplit
- Initial Thought: The rules of the problem is straightforward as it requires determining the longest sequence generated by splitting a number and multiplying its parts until reaching a single-digit number. My initial approach is to use recursion with memorization. I would convert the number to a string first to facilitate splitting into parts (public for input. Converted to string in private part). The main idea is to check all possible splits of the number, compute the product of the parts, and recursively determine the longest sequence from that product. I need to ensure that I handle leading zeros correctly and account for all possible combinations of splits.
- Reflections: I encountered an issue where the function returned an incorrect length for specific test cases. For example, it outputted 6 instead of 7 for the input 876. After reviewing my code, I realized that my approach did not adequately explore all possible splits, particularly those involving three parts. After making adjustments to consider all splits correctly, I achieved the expected output. The memorization helped improve performance, and overall, I'm satisfied with the final implementation and the readability which I did the best I could.

CountExpressions:
- Initial Thought: The rule of the problem requires forming as many different expressions as possible using the numbers x and y exactly twice, with the operators +, -, and *, such that the result equals a given value val. My initial approach is to generate all permutations of the numbers [x, x, y, y] and all combinations of the operators. For each combination, I will construct the expression and evaluate it from left to right. This involves a nested loop for operators and generating permutations for the numbers.
- Reflections: Initially, I faced challenges in ensuring the correct evaluation of expressions since operations must be performed left to right without operator precedence. I also needed to handle duplicate expressions by using a set to store unique expressions. After implementing the solution, it correctly handled most test cases. There are some special test cases in gradescope where I couldn't understand why the codes won't output the correct result and I couldn't figure it out, after spending lots of time on. The final implementation is as efficient and as readable as possible.

ColorfulRabbits:
- Initial Thought: The rule of the problem is very easy to understand as it requires determining the minimum possible number of rabbits in a town based on their replies. Each reply indicates how many other rabbits share the same color as the rabbit giving the reply. My initial approach is to group the replies by their values and then calculate the minimum number of rabbits required for each group. Specifically, if a rabbit says there are ( k ) other rabbits of the same color, there must be ( k + 1 ) rabbits of that color in total. By counting the occurrences of each reply and determining the number of groups needed, we can compute the total minimum number of rabbits. I used unordered map and for-loop to count replies and based on it, another for-loop to determine the final result by grouping.